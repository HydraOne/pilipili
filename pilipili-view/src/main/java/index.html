<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/spark-md5/3.0.0/spark-md5.js"></script>
</head>
<body>
hello
<form name="upload" enctype="multipart/form-data">
    <input id="file" type="file" name="video">
    <input id="upload" type="button" value="上传">
</form>
</body>
<script type="text/javascript">
    let bytesPerPiece = 1024 * 1024; // 每个文件切片大小定为1MB .
    let uploadedPiece = 0;
    //发送请求

    $("#upload").click(upload)

    function upload() {
        let blob = document.getElementById("file").files[0];
        let fileInfoForm = new FormData();
        let fileName = blob.name;
        let fileSize = blob.size;
        fileInfoForm.append("name", fileName);
        fileInfoForm.append("size", fileSize);
        uploadFileInfo(fileInfoForm, function (res) {
            let fileId = res['uuid'];
            startUploadFile(fileId, blob)
        })
    }

    function countMD5(chunk, callback) {
        let fileReader = new FileReader();
        fileReader.readAsArrayBuffer(chunk);
        let md5Str = '';
        fileReader.onloadend = function () {
            md5Str = SparkMD5.ArrayBuffer.hash(fileReader.result);
            callback(md5Str);
        };
    }

    function uploadFileToServer(md5, fileId, blob, index, count) {
        // 给每一片切片设置名字，名字的值为原始名称加索引，这样做是为了让后端可以按照索引顺序合并图片。
        let sliceIndex = blob.name + index;
        // 利用formData来传递数据
        let formData = new FormData();
        formData.append("file", blob);
        formData.append("index", index);
        formData.append("truthMD5", md5);
        $.ajax({
            url: `http://localhost:9000/file/upload/`+fileId +'/' + md5 + '/' + index,
            type: 'POST',
            data: formData,
            processData: false,  // 不处理数据
            contentType: false,  // 不设置内容类型
        }).done(function (res) {
            console.log(res);
            console.log(count + ":" + index)
            if (count === ++uploadedPiece) {
                console.log("上传结束,请求拼接接口，将切片信息拼接完整，返回图片url");
                $.post('http://localhost:9000/file/merge', {'fileId': fileId}, function (data) {
                    console.log(data);
                })
            }
        }).fail(function (res) {
            console.log("上传失败")
        });
    }

    function uploadFileInfo(fileInfoForm, successCall, failCall) {
        $.ajax({
            url: 'http://localhost:9000/file/uploadFileInfo',
            type: 'POST',
            data: fileInfoForm,
            sync: true,
            processData: false,  // 不处理数据
            contentType: false,  // 不设置内容类型
        }).done(function (res) {
            console.log(res);
            successCall(res)
        }).fail(function (res) {
            failCall(res);
        });
    }

    function startUploadFile(fileId, blob) {
        let start = 0;
        // 切割的结束位置
        let end;
        // 回调计数器
        let filesize = blob.size;
        //切片总数
        let count = Math.ceil(filesize / bytesPerPiece);
        // 切片的索引
        let index = 0;
        // 启动while循环对文件切片
        while (start < filesize) {
            // 设置切片的结束位置
            end = start + bytesPerPiece;
            // 对最后一片数据进行处理（可以省略）
            if (end > filesize) {
                end = filesize;
            }
            // 切割文件
            let chunk = blob.slice(start, end);//切割文件
            let part = ++index;
            let promise = new Promise(function (resolve, reject){
                countMD5(chunk, function (md5Str) {
                    resolve(md5Str);
                })
            });
            promise.then(function (md5Str){
                uploadFileToServer(md5Str, fileId,chunk,part, count);
            })
            start = end;
        }
    }

</script>
</html>